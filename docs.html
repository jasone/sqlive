<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"./>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"./>
    <title>SQLIVE</title>
    <meta name="viewport" content="width=device-width"./>
    <meta property="og:title" content="Getting started SQLIVE"./>
    <meta property="og:type" content="website"./>
    <meta property="og:url" content="./docs.html"./>
    <meta property="og:description" content="SQLIVE docs"./>
    <meta name="twitter:card" content="summary"./>
    <link rel="shortcut icon" href="./img/favicon.png"./>
    <link rel="stylesheet" href=".//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"./>
    <link rel="stylesheet" href="./css/main.css"./>
  </head>
  <body class="sideNavVisible doc">
    <div class="fixedHeaderContainer">
      <div class="headerWrapper wrapper">
        <header>
	  <a href="index.html">
	    <div style="color:#B22222;border-style:solid;border-width:1px;padding-left:5px;padding-right:5px;border-radius:5px;">&#9673; SQLIVE</div>
	    <h2 class="headerTitle">SQLIVE</h2>
	  </a>
	  <div class="navigationWrapper navigationSlider">
	    <nav class="slidingNav">
	      <ul class="nav-site nav-site-internal">
		      <li class="">
		        <a href="./docs.html" target="_self">Docs</a>
		      </li>
		      <li class="">
		        <a href="./about.html" target="_self">About</a>
		      </li>
	      </ul>
	    </nav>
	  </div>
	</header>
    </div>
    </div>
    <div class="container mainContainer">
      <div class="wrapper">
        <div class="post">
          <header class="postHeader">
            <h1> </h1>
          </header>
          <article>
<script>
function setClipboard(text) {
    var type = "text/plain";
    var blob = new Blob([text], { type });
    var data = [new ClipboardItem({ [type]: blob })];

    navigator.clipboard.write(data).then(
        function () {
        /* success */
        },
        function () {
        /* failure */
        }
    );
}

function CopyToClipboard(id) {
    var r = document.createRange();
    r.selectNode(document.getElementById(id));
    window.getSelection().removeAllRanges();
    window.getSelection().addRange(r);
    document.execCommand('copy');
    var text = window.getSelection().toString();
    var result = "";
    var inCommand = false;
    for(let i = 0; i < text.length; i++) {
        var c = text.charAt(i);
        if(inCommand) {
            result = result + c;
        }
        if(c == '$') {
            inCommand = true;
        }
        if(c == '\n') {
            inCommand = false;
        }
    }
    text = result;
    window.getSelection().removeAllRanges();
    setClipboard(text);
}
</script>

<h1> </h1>

<h2>Download</h2>

<p>A free version of sqlive is available for non-commercial use (<a href="https://github.com/SkipLabs/sqlive/blob/main/LICENSE.md">license</a>).
You can download it here:
<a href="https://github.com/SkipLabs/sqlive/raw/main/bin/sqlive-linux-x64-0.9.bin">https://github.com/SkipLabs/sqlive/raw/main/bin/sqlive-linux-x64-0.9.bin</a></p>

<p>For commercial use, please contact us at <a href="mailto:contact@skiplabs.io">contact@skiplabs.io</a>.</p>

<h2>Linux</h2>

<p>SQLIVE is only available for x64-Linux.
If you don't have linux on your machine, you can install <a href="https://docs.microsoft.com/en-us/windows/wsl/install">WSL</a> on windows or
<a href="https://docs.docker.com/desktop/mac/install/">docker</a> for mac.
Although SQLIVE runs on most versions of Linux, SkipLabs will only maintain a version running on the latest <a href="https://wiki.ubuntu.com/Releases">ubuntu LTS</a>.
We highly recommend you use that version,
but if you need to run sqlive on a different platform, please contact us at <a href="mailto:contact@skiplabs.io">contact@skiplabs.io</a>.</p>

<h2>Install</h2>

<p>First, install the binary file (preferably in /usr/local/bin). Make sure you don't rename the original binary, because
some SQLIVE updates will require you to export your data to a newer version of the database. So it is safer to keep all
the different versions of SQLIVE around in case you need them.</p>

<p><pre><code id="code115" class="hljs">$ sudo mv sqlive-linux-x64-0.9.bin /usr/local/bin
$ sudo ln -s /usr/local/bin/sqlive-linux-x64-0.9.bin /usr/local/bin/sqlive
</code><button style="float: right;" onclick="CopyToClipboard('code115');return false;">Copy</button><div>  </div></pre></p>

<h2>Initialization</h2>

<p>SQLIVE stores all of its data in a file specified by the user.
To initialize a database file, use the option --init.</p>

<p><pre><code id="code124" class="hljs">$ sqlive --init /tmp/test.db
</code><button style="float: right;" onclick="CopyToClipboard('code124');return false;">Copy</button><div>  </div></pre></p>

<p>Make sure you do not manipulate this file (copy, rename etc ...) while other processes are accessing the database.
By default, the maximum capacity of the database is 16GB. Meaning, the database will only be accessible in read-only
mode once that limit is reached. If you need a larger capacity, you can use the option --capacity at initialization time.</p>

<p><pre><code id="code131" class="hljs">$ sqlive --init /tmp/test.db --capacity $YOUR_CHOICE_IN_BYTES
</code><button style="float: right;" onclick="CopyToClipboard('code131');return false;">Copy</button><div>  </div></pre></p>

<h2>Loading data</h2>

<p>Let's first load some mock data to play with the database.</p>

<p><pre><code id="code138" class="hljs">$ wget https://github.com/SkipLabs/sqlive/raw/main/example/tiny_TPCH.sql
$ cat tiny_TPCH.sql | sqlive --data /tmp/test.db
</code><button style="float: right;" onclick="CopyToClipboard('code138');return false;">Copy</button><div>  </div></pre></p>

<p>This created two tables. One named customer the other named orders.
Here are their schema:</p>

<p><pre><code id="code145" class="hljs">$ sqlive --dump-tables --data /tmp/test.db
CREATE TABLE customer (
  c_custkey INTEGER PRIMARY KEY,
  c_name TEXT,
  c_address TEXT,
  c_nationkey INTEGER,
  c_phone TEXT,
  c_acctbal FLOAT,
  c_mktsegment TEXT,
  c_comment TEXT
);
CREATE TABLE orders (
  o_orderkey INTEGER PRIMARY KEY,
  o_custkey INTEGER,
  o_orderstatus TEXT,
  o_totalprice FLOAT,
  o_orderdate TEXT,
  o_orderpriority TEXT,
  o_clerk TEXT,
  o_shippriority INTEGER,
  o_comment TEXT
);
</code><button style="float: right;" onclick="CopyToClipboard('code145');return false;">Copy</button><div>  </div></pre></p>

<p>Note that SQLIVE only supports 3 types:
64 bits integers (INTEGER),
64 bits floating point numbers (FLOAT)
and UTF-8 strings (TEXT).</p>

<p>By looking at the schema, we can see that the two tables are related through the columns c_custkey and o_custkey.
Each order identifies the customer that passed the order through a unique identifier (as it is often the case in
relational databases). But what happens when a query needs to both process an order and lookup the data associated to the
user that passed the order? This requires the use of a join, which you will see, work a bit differently in SQLIVE.</p>

<h2>Joins</h2>

<p>Let's try to run a basic join:</p>

<p><pre><code id="code183" class="hljs">$ echo "select * from customer, orders where c_custkey = o_custkey;" | sqlive --data /tmp/test.db
</code><button style="float: right;" onclick="CopyToClipboard('code183');return false;">Copy</button><div>  </div></pre></p>

<p>Surprisingly, this leads to an error (the error can be ignored with the option --always-allow-join):</p>

<p><pre><code id="code188" class="hljs">$ echo "select * from customer, orders where c_custkey = o_custkey;" | sqlive --data /tmp/test.db
select * from customer, orders where c_custkey = o_custkey;
^
|
 ----- ERROR
Error: line 1, characters 0-0:
Joins outside of virtual views are considered bad practice in sqlive.
You should first create a virtual view joining customer and orders with a query of the form:
create virtual view customer_orders as select * from customer, orders where c_custkey = o_custkey;
And then use customer_orders directly.
PS: You can ignore this error message with --always-allow-join (not recommended).
PS2: don't forget you can add indexes to virtual views.
</code><button style="float: right;" onclick="CopyToClipboard('code188');return false;">Copy</button><div>  </div></pre></p>

<p>The error message is pretty explicit. Joins outside of a virtual view are considered bad practice. But why is that?
The reason is that a join is an expensive operation. When you run it outside of a virtual view, you will have
to repeat that operation every single time the query is run.
A better approach is to create a virtual view once and for all and have all the subsequent queries
share the same virtual view. Let's follow the advice given in the error message:</p>

<p><pre><code id="code208" class="hljs">$ echo "create virtual view customer_orders as select * from customer, orders where c_custkey = o_custkey;" | sqlive --data /tmp/test.db
</code><button style="float: right;" onclick="CopyToClipboard('code208');return false;">Copy</button><div>  </div></pre></p>

<p>This command created the virtual view "customer_orders", which can now be used like any other table.
Let's find the orders from customer number 889.</p>

<p><pre><code id="code214" class="hljs">$ echo "select * from customer_orders where c_custkey = 889;" | sqlive --data /tmp/test.db
889|Customer#000000889|pLvfd7drswfAcH8oh2seEct|13|23-625-369-6714|3635.3499999989999|FURNITURE|inal ideas. slowly pending frays are. fluff|931|889|F|155527.98000000001|1992-12-07|1-URGENT|Clerk#000000881|0|ss packages haggle furiously express, regular deposits. even, e
</code><button style="float: right;" onclick="CopyToClipboard('code214');return false;">Copy</button><div>  </div></pre></p>

<p>And that works for any query involving customers and orders. Instead of recomputing expensive joins every single time orders and customers are
involved, you can run those queries directly on the virtual view customer_orders.
To speed things up, we recommend you add indexes to your virtual views:</p>

<p><pre><code id="code222" class="hljs">$ echo "create index customer_orders_c_custkey ON customer_orders(c_custkey);" | sqlive --data /tmp/test.db
</code><button style="float: right;" onclick="CopyToClipboard('code222');return false;">Copy</button><div>  </div></pre></p>

<p>If you are unsure about your queries, you can ask SQLIVE to list the indexes that were used for a particular query through the option --show-used-indexes.
This option is particularly useful when trying to optimize your queries.</p>

<p><pre><code id="code228" class="hljs">$ echo "select * from customer_orders where c_custkey = 889;" | sqlive --data /tmp/test.db --show-used-indexes
USING INDEX: customer_orders_c_custkey
...
</code><button style="float: right;" onclick="CopyToClipboard('code228');return false;">Copy</button><div>  </div></pre></p>

<h2>Connections</h2>

<p>Virtual views can be used to maintain a query up-to-date at all times, as we have just seen, but
they can also be used to get notified when changes occurs.</p>

<p>For example, let's create a query that tracks all the customer with a negative balance.</p>

<p><pre><code id="code240" class="hljs">$ echo "create virtual view negative_balance as select * from customer where c_acctbal &lt; 0.0;" | sqlive --data /tmp/test.db
</code><button style="float: right;" onclick="CopyToClipboard('code240');return false;">Copy</button><div>  </div></pre></p>

<p>The creation of the virtual view does not trigger notifications. We need to "connect" to that view in order to receive them.</p>

<p><pre><code id="code245" class="hljs">$ sqlive --data /tmp/test.db --connect negative_balance --stream /tmp/negative_balance
6043
</code><button style="float: right;" onclick="CopyToClipboard('code245');return false;">Copy</button><div>  </div></pre></p>

<p>With this command we instructed SQLIVE to send all the changes relative to the virtual view "negative_balance" to the file /tmp/negative_balance.
In return, SQLIVE gave us the session number "6043", which will be useful to retrieve the status of that connection.</p>

<p>Let's have a look at the stream:</p>

<p><pre><code id="code254" class="hljs">$ tail /tmp/negative_balance
1       875|Customer#000000875|8pQ4YUYox0d|3|13-146-810-5423|-949.27999999899998|FURNITURE|ar theodolites snooze slyly. furiously express packages cajole blithely around the carefully r
1       880|Customer#000000880|ogwHmUUFa1QB69pAoYAAoB0rjbdsVpAQ552e5Q,|8|18-763-990-8618|-77.629999999000006|FURNITURE|regular requests. regular deposits ar
1       885|Customer#000000885|nNUbC73nPBCKLg0|5|15-874-471-4903|-959.94000000000005|HOUSEHOLD|sits impress regular deposits. slyly silent excuses grow
...
</code><button style="float: right;" onclick="CopyToClipboard('code254');return false;">Copy</button><div>  </div></pre></p>

<p>The format is pretty straight forward. It's a key/value format (separated by a tab) where the key is the number of repetitions of a row.
That number corresponds to the total number of rows with that value. So if a row was already present 23 times, and a transaction adds an additional instance of that row, that number would become 24.
However, in practice, the number of repetition is always going to be 0 or 1 (0 for removal).
Also note that for ephemeral streams (which will be introduced later), that number is always one.</p>

<p>You can check the status of every connection at all times with the option "--sessions".</p>

<p><pre><code id="code268" class="hljs">$ sqlive --sessions --data /tmp/test.db
6043    /negative_balance/      CONNECTED
</code><button style="float: right;" onclick="CopyToClipboard('code268');return false;">Copy</button><div>  </div></pre></p>

<p>We can see that our connection is live. You can decide to disconnect a sessions with the option --disconnect, but note that sessions will automatically disconnect in case of a problem.
The option --reconnect, restarts the session where it started to fail and sends all the data that was missed since the disconnection.</p>

<p>Let's see what happens when the data changes.</p>

<p><pre><code id="code277" class="hljs">$ echo "delete from customer where c_custkey = 11;" | sqlive --data /tmp/test.db
</code><button style="float: right;" onclick="CopyToClipboard('code277');return false;">Copy</button><div>  </div></pre></p>

<p>And see the effect in /tmp/negative_balance:</p>

<p><pre><code id="code282" class="hljs">$ tail  /tmp/negative_balance
...
&lt;-------- EMPTY LINE
&lt;-------- EMPTY LINE
 0     11|Customer#000000011|PkWS 3HlXqwTuzrKg633BEi|23|33-464-151-3439|-272.60000000000002|BUILDING|ckages. requests sleep slyly. quickly even pinto beans promise above the slyly regular pinto beans.
</code><button style="float: right;" onclick="CopyToClipboard('code282');return false;">Copy</button><div>  </div></pre></p>

<p>A new line appeared notifying us that the customer 11 has been removed.
If you paid attention, you can see that two empty lines where introduced before the notification.
Those lines are there to notify that the database finished a transaction (and is starting a new one). If you are ingesting the changes, you
can safely assume that the database was in a consistent state at that point.</p>

<h2>Diffing</h2>

<p>Streaming changes is fine, but the problem is that the changes are "pushed" to the user.
Sometimes, we will need to operate the other way around: the user will want to "pull" changes,
by asking periodically what has changed since the last time around.</p>

<p>Fortunately, SQLIVE has the solution: the --diff option.
Let's create a new connection, this time without the associated --stream option.</p>

<p><pre><code id="code303" class="hljs">$ sqlive --data /tmp/test.db --connect negative_balance
6058
</code><button style="float: right;" onclick="CopyToClipboard('code303');return false;">Copy</button><div>  </div></pre></p>

<p>And use the session number to get a "diff":</p>

<p><pre><code id="code309" class="hljs">$ sqlive --diff 6058 --since 0 --data /tmp/test.db
Time: 22
0       11|Customer#000000011|PkWS 3HlXqwTuzrKg633BEi|23|33-464-151-3439|-272.60000000000002|BUILDING|ckages. requests sleep slyly. quickly even pinto beans promise above the slyly regular pinto beans.
1       33|Customer#000000033|qFSlMuLucBmx9xnn5ib2csWUweg D|17|27-375-391-1280|-78.560000000000002|AUTOMOBILE|s. slyly regular accounts are furiously. carefully pending requests
1       37|Customer#000000037|7EV4Pwh,3SboctTWt|8|18-385-235-7162|-917.75|FURNITURE|ilent packages are carefully among the deposits. furiousl
...
</code><button style="float: right;" onclick="CopyToClipboard('code309');return false;">Copy</button><div>  </div></pre></p>

<p>Note that we used --diff in conjuction with --since. The --since option takes a timestamp produced by the database.
The timestamp 0 corresponds to the beginning of times. So asking a diff since time 0 will get you all the data associated
with a session.
Now pay attention to the first line that was returned: it says, "Time: 22". This is the new timestamp that you will have to keep for the next time around.</p>

<p>Let's try to make modifications:</p>

<p><pre><code id="code324" class="hljs">$ echo "delete from customer where c_custkey = 33;" | sqlive --data /tmp/test.db
</code><button style="float: right;" onclick="CopyToClipboard('code324');return false;">Copy</button><div>  </div></pre></p>

<p>And ask for the diff since time 22:</p>

<p><pre><code id="code329" class="hljs">$ sqlive --diff 6058 --since 22 --data /tmp/test.db
Time: 25
0       33|Customer#000000033|qFSlMuLucBmx9xnn5ib2csWUweg D|17|27-375-391-1280|-78.560000000000002|AUTOMOBILE|s. slyly regular accounts are furiously. carefully pending requests
</code><button style="float: right;" onclick="CopyToClipboard('code329');return false;">Copy</button><div>  </div></pre></p>

<p>The output gives us the next timestamp (22) plus the diff (the removal of the user 33).
You can repeat that operation as often as you want, at the rate you want, which makes
it convenient to run use cases that are polling data periodically.</p>

<h2>--stream vs --diff</h2>

<p>So when should you use a --stream? And when should you use a --diff?
You should use --stream if you need your changes to be live, and when you are confident that
the process that handles the changes will be able to keep up with the write rate of the database.</p>

<h2>Streaming</h2>

<p>SQLIVE also supports ephemeral tables called streams. They work exactly like a normal
sql table, except that they do not persist on disk.</p>

<p><pre><code id="code349" class="hljs">$ echo "create stream customer_connect_log (clog_custkey INTEGER, clog_time INTEGER);" | sqlive --data /tmp/test.db
</code><button style="float: right;" onclick="CopyToClipboard('code349');return false;">Copy</button><div>  </div></pre></p>

<p>We just declared an ephemeral data stream called customer_connect_log.
We can now use that table to log every time a customer connects to the system.
The difference with a "normal" table, is that the data is ephemeral (it will not persist on disk).
So what's the point of a stream you may ask? It comes in handy when trying to receive alerts.
For example, imagine we wanted to receive and alert every time a customer with a negative balance connects
to our system.</p>

<p>Step 1, we join the log with the table of customers, it's better to keep that as a separate step,
to be able to reuse the view "customer_log":</p>

<p><pre><code id="code362" class="hljs">$ echo "create virtual view customer_log as select * from customer_connect_log, customer where c_custkey = clog_custkey;" | sqlive --data /tmp/test.db
</code><button style="float: right;" onclick="CopyToClipboard('code362');return false;">Copy</button><div>  </div></pre></p>

<p>Step 2, we create a virtual view tracking connection of users with a negative balance:</p>

<p><pre><code id="code367" class="hljs">$ echo "create virtual view negative_bal_connection as select * from customer_log where c_acctbal &lt; 0.0;" | sqlive --data /tmp/test.db
</code><button style="float: right;" onclick="CopyToClipboard('code367');return false;">Copy</button><div>  </div></pre></p>

<p>Finally, we connect to that view:</p>

<p><pre><code id="code372" class="hljs">$ sqlive --connect negative_bal_connection --stream /tmp/negative_bal_connection --data /tmp/test.db
7083
</code><button style="float: right;" onclick="CopyToClipboard('code372');return false;">Copy</button><div>  </div></pre></p>

<p>Let's see what happens when we add data to the stream (using --load-csv is faster than INSERT statements when
manipulating streams):</p>

<p><pre><code id="code379" class="hljs">$ for i in {1..10000}; do echo "$i, $i"; done | sqlive --data /tmp/test.db --load-csv customer_connect_log
</code><button style="float: right;" onclick="CopyToClipboard('code379');return false;">Copy</button><div>  </div></pre></p>

<p>And check the result in /tmp/negative_bal_connection:</p>

<p><pre><code id="code384" class="hljs">$ tail -f /tmp/negative_bal_connection
1       934|934|934|Customer#000000934|UMAFCPYfCxn LhawyoEYoU9GZC7TORCX|12|22-119-576-7222|-592.69000000000005|AUTOMOBILE|fluffily requests. carefully even ideas snooze above the accounts. blithely bold platelets cajole
...
</code><button style="float: right;" onclick="CopyToClipboard('code384');return false;">Copy</button><div>  </div></pre></p>

<p>As expected, we got notified every time a customer with a negative balance connected.
In general, SQLIVE will never spawn threads or fork processes behind your back, to make the
performance more predictable. However, you should feel free to add multiple processes to speedup the ingestion of
data, including when targetting the same stream (Because SQLIVE supports multiple writers/readers)
In this case, we could for example get 10 processes writing on the stream customer_log at the same time:</p>

<p><pre><code id="code395" class="hljs">$ for j in {1..10}; do (for i in {1..10000}; do echo "$i, $i"; done | sqlive --data /tmp/test.db --load-csv customer_connect_log)&amp; done; wait
</code><button style="float: right;" onclick="CopyToClipboard('code395');return false;">Copy</button><div>  </div></pre></p>

<p>If you replace the '&amp;' with a ';', you will see a dramatic slow down in the ingestion rate of
the data.</p>

<p>On a laptop with more than 10 cores, the sequential time is 1.632s, while only 0.319s when
using 10 processes (so roughly 5X faster).</p>

<h2>Windows</h2>

<p>As mentioned earlier, streams are ephemeral. So what happens when using aggregate functions on them?</p>

<p><pre><code id="code408" class="hljs">$ echo "select count(*) from customer_connect_log;" | sqlive --data /tmp/test.db
^
|
 ----- ERROR
Error: line 1, characters 0-0:
Cannot use a stream for aggregates, use a window instead
</code><button style="float: right;" onclick="CopyToClipboard('code408');return false;">Copy</button><div>  </div></pre></p>

<p>We get an error. The error invites us to use a "window". A window is exactly like a stream, except that
it will persist data for a certain time. For example, let's say we want to keep the data received in the last
hour.</p>

<p><pre><code id="code420" class="hljs">$ echo "create window 3600 customer_connect_window (cw_custkey INTEGER, cw_time INTEGER);" | sqlive --data /tmp/test.db
</code><button style="float: right;" onclick="CopyToClipboard('code420');return false;">Copy</button><div>  </div></pre></p>

<p>The number 3600 corresponds to the number of seconds we want to persist the data.</p>

<p>Sometimes, instead of using the system clock, you will want to use a timestamp that was passed directly in the data.
When that's the case, annotate the field that corresponds to a timestamp as such:</p>

<p><pre><code id="code428" class="hljs">$ echo "create window 3600 customer_connect_window (cw_custkey INTEGER, cw_time INTEGER TIMESTAMP);" | sqlive --data /tmp/test.db
</code><button style="float: right;" onclick="CopyToClipboard('code428');return false;">Copy</button><div>  </div></pre></p>

<h2>Streams vs Windows</h2>

<p>You should always prefer streams to windows: they are faster and require less memory.
So only use windows when you have to use an aggregate function, typically for analytics.</p>

          </article>
            </div>
      </div>
      </div>
      </div>
</div>
</body>
</html>
